#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <PubSubClient.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <ArduinoJson.h>
#include <Preferences.h>
// NOTA: Sin Bluetooth para ahorrar memoria
// El usuario ingresa el TOKEN mostrado en LCD manualmente en la app


// Credenciales WiFi
#define WIFI_SSID "LOBO INFINITOS 2.4G"
#define WIFI_PASSWORD "ABCD97531"

// Configuración MQTT para EMQX Cloud
#define MQTT_SERVER "b5c0bf2b.ala.us-east-1.emqxsl.com"
#define MQTT_PORT 8883
#define MQTT_USERNAME "notificationmanager"
#define MQTT_PASSWORD "and123..."

// Intervalos de actualización
#define STATUS_UPDATE_INTERVAL 5000
#define MQTT_RECONNECT_INTERVAL 5000
#define MIN_NOTIFICATION_DISPLAY_TIME 4000
#define UNPAIR_BUTTON_HOLD_TIME 3000

// Configuración de pines
#define BUZZER_PIN 12
#define UNPAIR_BUTTON_PIN 13  // Botón para desvincular

// Definición del tamaño de la cola de notificaciones
#define MAX_QUEUE_SIZE 5

// Estructura para almacenar una notificación
struct Notification {
  String title;
  String content;
};

// Cola de notificaciones
Notification notificationQueue[MAX_QUEUE_SIZE];
int queueHead = 0;
int queueTail = 0;
int queueCount = 0;

// Variables para LCD
String currentLcdLine1 = "";
String currentLcdLine2 = "";
unsigned long lastNotificationShownTime = 0;
bool activeNotificationOnScreen = false;
int notificationCount = 0;  // Contador de notificaciones de esta sesión

// Variables para guardar última notificación y usuario conectado
String lastNotificationTitle = "";
String lastNotificationContent = "";
String connectedUsername = "";  // Usuario conectado desde la app

// Configuración de LCD
LiquidCrystal_I2C lcd(0x27, 16, 2);

// Cliente WiFi y MQTT
WiFiClientSecure espClient;
PubSubClient mqttClient(espClient);


// Variables globales
unsigned long lastLcdUpdate = 0;
unsigned long lastStatusUpdate = 0;
unsigned long lastMqttReconnectAttempt = 0xFFFFFFFF;  // Valor alto para forzar conexión inmediata al arrancar
unsigned long buttonPressStartTime = 0;
bool buttonWasPressed = false;

// Preferences para almacenamiento persistente
Preferences preferences;

// Token y estado de vinculación
String deviceToken = "";
bool isPaired = false;
String mqttTopic = "";

// ID del dispositivo (para mostrar)
String deviceId = "ESP32_" + String((uint32_t)(ESP.getEfuseMac() >> 32) ^ (uint32_t)ESP.getEfuseMac(), HEX).substring(0, 4);

// Certificado raíz SSL
const char* root_ca = \
"-----BEGIN CERTIFICATE-----\n" \
"MIIDrzCCApegAwIBAgIQCDvgVpBCRrGhdWrJWZHHSjANBgkqhkiG9w0BAQUFADBh\n" \
"MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\n" \
"d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBD\n" \
"QTAeFw0wNjExMTAwMDAwMDBaFw0zMTExMTAwMDAwMDBaMGExCzAJBgNVBAYTAlVT\n" \
"MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5j\n" \
"b20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IENBMIIBIjANBgkqhkiG\n" \
"9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4jvhEXLeqKTTo1eqUKKPC3eQyaKl7hLOllsB\n" \
"CSDMAZOnTjC3U/dDxGkAV53ijSLdhwZAAIEJzs4bg7/fzTtxRuLWZscFs3YnFo97\n" \
"nh6Vfe63SKMI2tavegw5BmV/Sl0fvBf4q77uKNd0f3p4mVmFaG5cIzJLv07A6Fpt\n" \
"43C/dxC//AH2hdmoRBBYMql1GNXRor5H4idq9Joz+EkIYIvUX7Q6hL+hqkpMfT7P\n" \
"T19sdl6gSzeRntwi5m3OFBqOasv+zbMUZBfHWymeMr/y7vrTC0LUq7dBMtoM1O/4\n" \
"gdW7jVg/tRvoSSiicNoxBN33shbyTApOB6jtSj1etX+jkMOvJwIDAQABo2MwYTAO\n" \
"BgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUA95QNVbR\n" \
"TLtm8KPiGxvDl7I90VUwHwYDVR0jBBgwFoAUA95QNVbRTLtm8KPiGxvDl7I90VUw\n" \
"DQYJKoZIhvcNAQEFBQADggEBAMucN6pIExIK+t1EnE9SsPTfrgT1eXkIoyQY/Esr\n" \
"hMAtudXH/vTBH1jLuG2cenTnmCmrEbXjcKChzUyImZOMkXDiqw8cvpOp/2PV5Adg\n" \
"06O/nVsJ8dWO41P0jmP6P6fbtGbfYmbW0W5BjfIttep3Sp+dWOIrWcBAI+0tKIJF\n" \
"PnlUkiaY4IBIqDfv8NZ5YBberOgOzW6sRBc4L0na4UU+Krk2U886UAb3LujEV0ls\n" \
"YSEY1QSteDwsOoBrp+uvFRTp2InBuThs4pFsiv9kuXclVzDAGySj4dzp30d8tbQk\n" \
"CAUw7C29C79Fv1C5qfPrmAESrciIxpg0X40KPMbp1ZWVbd4=\n" \
"-----END CERTIFICATE-----\n";

/**
 * Genera token único de 6 caracteres:
 * - Primeros 3: derivados del ID único del ESP32 (garantiza unicidad del dispositivo)
 * - Últimos 3: aleatorios (variabilidad por sesión/reinicio)
 * Formato: XXX-YYY donde XXX=deviceID, YYY=aleatorio
 */
String generateUniqueToken() {
  const char chars[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  String token = "";
  
  // --- Primeros 3 caracteres: del ID único del ESP32 ---
  uint64_t chipId = ESP.getEfuseMac();
  // Usar XOR de las dos mitades del MAC para mejor distribución
  uint32_t deviceHash = (uint32_t)(chipId >> 32) ^ (uint32_t)chipId;
  
  for (int i = 0; i < 3; i++) {
    token += chars[deviceHash % 36];
    deviceHash /= 36;
  }
  
  // --- Últimos 3 caracteres: aleatorios ---
  // Seed con múltiples fuentes de entropía
  uint32_t seed = ESP.getEfuseMac() ^ millis() ^ micros();
  seed ^= analogRead(0);  // Ruido analógico para más aleatoriedad
  randomSeed(seed);
  
  for (int i = 0; i < 3; i++) {
    token += chars[random(0, 36)];
  }
  
  return token;
}


/**
 * Muestra texto en LCD
 */
void showOnLCD(String line1, String line2) {
  lcd.clear();
  
  lcd.setCursor(0, 0);
  if (line1.length() <= 16) {
    lcd.print(line1);
  } else {
    lcd.print(line1.substring(0, 16));
  }
  currentLcdLine1 = line1;
  
  lcd.setCursor(0, 1);
  if (line2.length() <= 16) {
    lcd.print(line2);
  } else {
    lcd.print(line2.substring(0, 16));
  }
  currentLcdLine2 = line2;
}

/**
 * Actualiza estado en LCD
 */
void updateStatusLCD() {
  if (millis() - lastStatusUpdate < STATUS_UPDATE_INTERVAL) {
    return;
  }
  lastStatusUpdate = millis();

  if (activeNotificationOnScreen) {
    return;
  }
  
  String newLine1 = "";
  String newLine2 = "";
  
  if (WiFi.status() == WL_CONNECTED && mqttClient.connected()) {
    if (isPaired) {
      newLine1 = deviceId;
      newLine2 = "Vinculado";
    } else {
      newLine1 = "TOKEN:";
      newLine2 = deviceToken;
    }
  } else if (WiFi.status() == WL_CONNECTED) {
    newLine1 = deviceId;
    newLine2 = "MQTT Desconect.";
  } else {
    newLine1 = deviceId;
    newLine2 = "WiFi Desconect.";
  }
  
  if (newLine1 != currentLcdLine1 || newLine2 != currentLcdLine2) {
    showOnLCD(newLine1, newLine2);
  }
}

/**
 * Sonido de notificación
 */
void playNotificationSound() {
  pinMode(BUZZER_PIN, OUTPUT);
  
  for (int i = 0; i < 2; i++) {
    digitalWrite(BUZZER_PIN, HIGH);
    delay(100);
    digitalWrite(BUZZER_PIN, LOW);
    delay(100);
  }
  
  digitalWrite(BUZZER_PIN, HIGH);
  delay(200);
  digitalWrite(BUZZER_PIN, LOW);
}

/**
 * Melodía de vinculación exitosa
 */
void playPairingSound() {
  pinMode(BUZZER_PIN, OUTPUT);
  
  int tones[] = {262, 330, 392, 523};
  int durations[] = {150, 150, 150, 300};
  
  for (int i = 0; i < 4; i++) {
    tone(BUZZER_PIN, tones[i], durations[i]);
    delay(durations[i] + 50);
  }
  noTone(BUZZER_PIN);
}

/**
 * Melodía de desvinculación
 */
void playUnpairSound() {
  pinMode(BUZZER_PIN, OUTPUT);
  
  // Melodía descendente
  int tones[] = {523, 392, 330, 262};
  int durations[] = {150, 150, 150, 300};
  
  for (int i = 0; i < 4; i++) {
    tone(BUZZER_PIN, tones[i], durations[i]);
    delay(durations[i] + 50);
  }
  noTone(BUZZER_PIN);
}

/**
 * Callback MQTT
 * Recibe notificaciones y mensajes de conexión
 */
void mqttCallback(char* topic, byte* payload, unsigned int length) {
  Serial.print("Mensaje en [");
  Serial.print(topic);
  Serial.print("]: ");
  
  String message = "";
  for (int i = 0; i < length; i++) {
    message += (char)payload[i];
  }
  Serial.println(message);
  
  // Parsear JSON
  DynamicJsonDocument doc(512);
  DeserializationError error = deserializeJson(doc, message);

  if (!error) {
    // Verificar si es un mensaje de conexión
    String msgType = doc["type"].as<String>();
    
    if (msgType == "connection") {
      // Mensaje de conexión desde la app Android
      String username = doc["username"].as<String>();
      Serial.println("Usuario conectado: " + username);
      
      // Guardar usuario conectado
      connectedUsername = username;
      
      // Marcar como vinculado
      isPaired = true;
      preferences.putBool("paired", true);
      
      // Mostrar en LCD
      showOnLCD(username, "conectado!");
      playPairingSound();
      
      // Después de 3 segundos, mostrar última notificación o estado
      delay(3000);
      return;
    }
    
    if (msgType == "disconnect") {
      // Mensaje de desconexión desde la app Android
      String username = doc["username"].as<String>();
      Serial.println("Usuario desconectado: " + username);
      
      // Limpiar usuario conectado
      connectedUsername = "";
      
      // Marcar como NO vinculado
      isPaired = false;
      preferences.putBool("paired", false);
      
      // Mostrar en LCD
      showOnLCD(username.length() > 0 ? username : "Usuario", "desconectado");
      playUnpairSound();
      
      // Después de 3 segundos, mostrar token para nueva vinculación
      delay(3000);
      showOnLCD("TOKEN:", deviceToken);
      return;
    }
    
    // Es una notificación normal
    String title = doc["title"].as<String>();
    String content = doc["content"].as<String>();
    String appName = doc["appName"].as<String>();
    
    // Filtro: solo mostrar notificaciones de Yape
    // Descomenta las siguientes lineas si quieres filtrar solo Yape:
    // if (appName.indexOf("Yape") == -1 && appName.indexOf("yape") == -1) {
    //   Serial.println("Notificacion ignorada (no es Yape): " + appName);
    //   return;
    // }
    
    if (title.length() > 0 && content.length() > 0) {
      // Agregar a cola
      if (queueCount < MAX_QUEUE_SIZE) {
        notificationQueue[queueTail].title = title;
        notificationQueue[queueTail].content = content;
        
        queueTail = (queueTail + 1) % MAX_QUEUE_SIZE;
        queueCount++;
        
        Serial.println("Notificacion encolada: " + title + " (" + appName + ")");
      } else {
        Serial.println("Cola llena, notificacion descartada");
      }
    }
  } else {
    Serial.println("Error parseando JSON");
  }
}

/**
 * Procesa cola de notificaciones
 */
void processNotificationQueue() {
  // Esperar tiempo minimo antes de mostrar siguiente notificacion
  if (activeNotificationOnScreen && 
      (millis() - lastNotificationShownTime) < MIN_NOTIFICATION_DISPLAY_TIME) {
    return;
  }
  
  activeNotificationOnScreen = false;
  
  if (queueCount > 0) {
    Notification notification = notificationQueue[queueHead];
    notificationCount++;  // Incrementar contador
    
    // Guardar última notificación
    lastNotificationTitle = notification.title;
    lastNotificationContent = notification.content;
    
    Serial.println("Mostrando #" + String(notificationCount) + ": " + notification.title);
    showOnLCD(notification.title, notification.content);
    playNotificationSound();
    
    queueHead = (queueHead + 1) % MAX_QUEUE_SIZE;
    queueCount--;
    lastNotificationShownTime = millis();
    activeNotificationOnScreen = true;
  } else if (!activeNotificationOnScreen && notificationCount > 0) {
    // Mostrar última notificación cuando no hay en cola
    if (isPaired && lastNotificationTitle.length() > 0) {
      if (currentLcdLine1 != lastNotificationTitle) {
        showOnLCD(lastNotificationTitle, lastNotificationContent);
      }
    }
  }
}

/**
 * Conecta a WiFi
 */
void setupWiFi() {
  delay(10);
  Serial.println();
  Serial.print("Conectando a WiFi...");
  
  showOnLCD("Conectando WiFi", WIFI_SSID);

  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  Serial.println("\nWiFi conectado");
  Serial.println("IP: " + WiFi.localIP().toString());
  
  showOnLCD("WiFi OK", WiFi.localIP().toString());
  delay(1000);
}

/**
 * Conecta a MQTT
 */
boolean connectMQTT() {
  if (WiFi.status() != WL_CONNECTED) {
    return false;
  }
  
  if (!mqttClient.connected() && (millis() - lastMqttReconnectAttempt > MQTT_RECONNECT_INTERVAL)) {
    lastMqttReconnectAttempt = millis();
    
    Serial.print("Conectando MQTT...");
    showOnLCD("Conectando MQTT", MQTT_SERVER);
    
    String clientId = "ESP32_" + String(random(0xffff), HEX);
    
    if (mqttClient.connect(clientId.c_str(), MQTT_USERNAME, MQTT_PASSWORD)) {
      Serial.println("MQTT Conectado");
      
      // Suscribirse al topic con el token
      mqttClient.subscribe(mqttTopic.c_str());
      Serial.println("Suscrito a: " + mqttTopic);
      
      if (isPaired) {
        showOnLCD(deviceId, "Vinculado");
      } else {
        showOnLCD("TOKEN:", deviceToken);
      }
      
      return true;
    } else {
      Serial.print("MQTT Error: ");
      Serial.println(mqttClient.state());
      showOnLCD("MQTT Error", "Reintentando...");
      return false;
    }
  }
  return true;
}

/**
 * Fuerza conexión MQTT inmediata (sin verificar intervalo de tiempo)
 * Usar solo en setup() para asegurar conexión al arrancar
 */
void forceConnectMQTT() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi no conectado, no se puede conectar MQTT");
    return;
  }
  
  Serial.println("Intentando conexión MQTT inmediata...");
  showOnLCD("Conectando MQTT", MQTT_SERVER);
  
  String clientId = "ESP32_" + String(random(0xffff), HEX);
  
  int attempts = 0;
  while (!mqttClient.connected() && attempts < 5) {
    attempts++;
    Serial.print("Intento #");
    Serial.println(attempts);
    
    if (mqttClient.connect(clientId.c_str(), MQTT_USERNAME, MQTT_PASSWORD)) {
      Serial.println("MQTT Conectado!");
      
      // Suscribirse al topic con el token
      mqttClient.subscribe(mqttTopic.c_str());
      Serial.println("Suscrito a: " + mqttTopic);
      
      lastMqttReconnectAttempt = millis();  // Actualizar timestamp
      
      if (isPaired) {
        showOnLCD(deviceId, "Vinculado");
      } else {
        showOnLCD("TOKEN:", deviceToken);
      }
      return;
    } else {
      Serial.print("MQTT Error: ");
      Serial.println(mqttClient.state());
      delay(1000);  // Esperar antes de reintentar
    }
  }
  
  Serial.println("No se pudo conectar MQTT después de 5 intentos");
  showOnLCD("MQTT Error", "Reintenta manual");
}

/**
 * Maneja botón de desvinculación
 */
void handleUnpairButton() {
  bool buttonPressed = (digitalRead(UNPAIR_BUTTON_PIN) == LOW);
  
  if (buttonPressed && !buttonWasPressed) {
    // Botón recién presionado
    buttonPressStartTime = millis();
    buttonWasPressed = true;
  }
  
  if (!buttonPressed && buttonWasPressed) {
    // Botón liberado
    buttonWasPressed = false;
  }
  
  if (buttonPressed && buttonWasPressed) {
    // Botón mantEnido presionado
    unsigned long holdTime = millis() - buttonPressStartTime;
    
    if (holdTime >= UNPAIR_BUTTON_HOLD_TIME && isPaired) {
      // Desvincular dispositivo
      Serial.println("Desvinculando dispositivo...");
      
      mqttClient.unsubscribe(mqttTopic.c_str());
      
      // Generar nuevo token único
      deviceToken = generateUniqueToken();
      mqttTopic = "n/" + deviceToken;
      isPaired = false;
      
      // Guardar en preferences
      preferences.putString("token", deviceToken);
      preferences.putBool("paired", false);
      
      showOnLCD("NUEVO TOKEN:", deviceToken);
      playUnpairSound();
      
      // Resubscribirse a nuevo topic
      delay(500);
      mqttClient.subscribe(mqttTopic.c_str());
      Serial.println("Nuevo topic: " + mqttTopic);
      
      // Reset button state
      buttonWasPressed = false;
    }
  }
}

void setup() {
  Serial.begin(115200);
  
  // Configurar pines
  pinMode(BUZZER_PIN, OUTPUT);
  digitalWrite(BUZZER_PIN, LOW);
  
  pinMode(UNPAIR_BUTTON_PIN, INPUT_PULLUP);
  
  // Inicializar LCD
  Wire.begin(21, 22);
  lcd.init();
  lcd.backlight();
  
  showOnLCD("Iniciando...", "ESP32 MQTT");
  delay(1000);


  // Inicializar Preferences
  preferences.begin("device", false);
  
  // SIEMPRE generar token único en cada reinicio
  // Token de 6 caracteres: 3 del deviceID + 3 aleatorios
  deviceToken = generateUniqueToken();
  isPaired = false;
  Serial.println("Token unico generado: " + deviceToken);
  Serial.println("Formato: [DeviceID-3chars][Random-3chars]");
  
  mqttTopic = "n/" + deviceToken;
  Serial.println("MQTT Topic: " + mqttTopic);
  
  // Configurar SSL
  espClient.setCACert(root_ca);
  
  // Configurar MQTT
  mqttClient.setServer(MQTT_SERVER, MQTT_PORT);
  mqttClient.setCallback(mqttCallback);
  
  // Conectar WiFi
  setupWiFi();
  
  // Test buzzer
  playNotificationSound();
  delay(500);
  
  // Mostrar token si no está vinculado
  if (!isPaired) {
    showOnLCD("TOKEN:", deviceToken);
  }
  
  // FORZAR conexión MQTT inmediata al arrancar
  Serial.println("Forzando conexión MQTT inicial...");
  forceConnectMQTT();
}

void loop() {
  // Verificar WiFi
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi perdido, reconectando...");
    setupWiFi();
  }
  
  // Verificar MQTT
  if (!mqttClient.connected()) {
    connectMQTT();
  }
  
  // Mantener conexión MQTT
  mqttClient.loop();
  
  // Procesar notificaciones
  processNotificationQueue();
  
  // Actualizar LCD
  updateStatusLCD();
  
  // Manejar botón de desvinculación
  handleUnpairButton();
  
  delay(10);
}